# 3.1 一般运算符

一般运算符分为二元运算符和一元运算符。

定义一个二元运算符的语法如下：

```aoi
op lhs opName rhs: LhsType <> RhsType -> ResultType {
    ...
}
```

定义一个一元运算符的语法如下：


```aoi
op opName rhs: Type -> ResultType {
    ...
}
```

其中，`opName` 是运算符名称，`lhs` 和 `rhs` 是两个声明模式，调用二元运算符时，左右两侧的值会分别赋给 `lhs` 和 `rhs` 声明的变量，一元运算符则为右侧赋给 `rhs`。声明的变量可以在运算符主体块中使用。`LhsType` `RhsType` `ResultType` 是三个类型，分别表示左侧、右侧和结果的类型。`{ ... }` 是运算符主体块，代表运算符执行的内容，是一个类型为 `ResultType` 的表达式块。特殊地，返回值类型为 `()` 的运算符运算符主体块可以为语句块。`<>` 是一个占位符，表示一个二元运算。

除了通用的标识符命名标准，运算符的标识符也可以是一个未被使用的 Unicode 标点符号（Punctuation），例如 `†` `√` 等。在词法分析时，相连的多个符号会被解析为多个 token，例如 `√√42` 会被解析为 `√` `√` `42`。

这种定义语法看似比较混乱，但现在，人人写代码都会有代码高亮，在有高亮的情况下，要定义的主体将比较容易辨认。同时，定义方式和调用形式一致，比较容易理解。

例如，以下代码定义了让字符串重复特定次数的运算符：

```aoi
op string repeat count: str <> int -> str {
    let res = "";
    for () in 0..count do {
        res += string;
    }
    res
}
```

如果运算符需要传入更多参数，可以传入元组并解构，例如，以下代码定义了判断一个数是否位于两数之间的运算符：

```aoi
op number between (min, max): int <> (int, int) -> bool {
    number >= min && number <= max
}
```

同时，也可以自定义基础运算符，`==` `!=` `??` `|>` 除外。例如，为自定义的向量结构体定义加法：

```aoi
struct Vector {
    x: float;
    y: float;
}
op a + b: Vector <> Vector -> Vector {
    new Vector {
        x: a.x + b.x,
        y: a.y + b.y
    }
}
```

Aoi 中没有方法，但是可以通过二元运算符来实现方法的作用：`op self method args`。但是，`method` 作为运算符，并不像方法那样被认为是「属于 `self` 的」，而单纯是一个作用于 `self` 和 `args` 的运算符。这种看法更接近本质，方法本质上也只是一个接收实例为参数的函数。在某些语言中，方法调用的形式，例如 `a.equalsTo(b)` `a.add(b)` 反而在形式上不太合理。

## `return` 表达式

在运算符的`return` 是一个 `never` 类型的表达式，它可以提前给出运算符返回值并中断运算符的执行。形如 `return value` 给出返回值 `value`。特殊地，`return` 代表返回 `()`。

Aoi 语言功能丰富时，可能会实现判断运算符主体块是否一定 `return` 的功能，这样就不用强制必须为表达式块了。
