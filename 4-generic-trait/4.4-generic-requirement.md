# 4.4 泛型要求

有了特征，就可以要求泛型参数满足某些特征，以使用特征内存在的运算符。比起类型的约束，更好的理解方式为要求一个特征的实现。它的本质是要求传入一个特征实现对应的虚表。

## 泛型运算符和泛型类型的泛型要求

定义泛型时，在运算符或类的泛型参数的末尾加冒号，并指定要求的特征：

```aoi
[T0, T1, ...: Trait0[...], Trait1[...], ...]
```

随后便可以使用这些特征中的运算符。使用特征中的运算符时和默认实现一样，可以隐式指定或用特征显式指定。

例如，以下代码定义了一个求最大值的运算符：

```aoi
op max[T: Ord[T]] (a, b): (T, T) -> T {
    if a >= b then a else b
}
```

它要求提供一个 `T` 的比较的实现，以比较两个 `T` 值的大小。

使用泛型运算符或泛型类型时，若要使用默认实现，且没有歧义，则无需显式指定实现。否则，对具名实现，用实现名，对默认实现，用特征显式指定。若无歧义，实现的泛型可以省略。例如，如果要求两个 `int` 的最大值，`max (4, 2)` `max[int] (4, 2)` `max[int: Ord] (4, 2)` `max[int: Ord[int]] (4, 2)` `max[Ord[int]] (4, 2)` 五种方式均能指定泛型和特征实现，其中 `max (4, 2)` 显然是最好的，它简洁同时语义清晰无歧义。

## 特征的泛型要求

特征也需要若干泛型参数：`Trait[T0, T1, ...]`，同样也可以对这些泛型参数提出要求：`Trait[T0, T1, ...: Trait0[...], Trait1[...], ...]`。特征的实现必须在这些泛型要求实现的基础上进行实现。

这类似于其它语言中的接口继承。

例如，为前文中的线性空间特征添加要求：

```aoi
trait VectorSpace[TNum, TVec: Add[TNum], Sub[TNum], Mul[TNum], Div[TNum], Add[TVec], Sub[TVec]] {
    op a * u: TNum <> TVec -> TVec;
}
```

其中，`Add` `Sub` `Mul` `Div` 是内置的特征，分别表示可以进行加减乘除法。`int` 和 `float` 都内置实现了这四个特征。

又例如，我们可以像 Rust 中一样设置 `PartialOrd` 和 `Ord` 两个特征，分别表示偏序和全序关系：

```aoi
trait PartialOrd[T] {
    op a < b: T <> T -> bool;
    op a <= b: T <> T -> bool {
        a < b || a == b
    }
    op a > b: T <> T -> bool {
        !(a <= b)
    }
    op a >= b: T <> T -> bool {
        !(a < b)
    }
}
trait Ord[T: PartialOrd[T]] {}
```

---

在实现带泛型要求的特征时，要先给出泛型要求的实现：`impl ... of Trait[Type0, Type1, ...: Impl0, Impl1]`

于是，我们可以如下实现 `VectorSpace[float, Vector]`:

```aoi
struct Vector {
    x: float;
    y: float;
}
impl of Add[Vector] {
    op u + v: Vector <> Vector -> Vector {
        new Vector {
            x: u.x + v.x,
            x: u.y + v.y
        }
    }
}
impl of VectorSpace[float, Vector] {
    op a * u: float <> Vector -> Vector {
        new Vector {
            x: a * u.x,
            y: a * u.y
        }
    }
}
```

在 `VectorSpace` 的默认实现中，`Add[TNum]` 等要求未显式给出，则使用这些特征的默认实现，即 `float` 的四则运算以及其中定义的 `Vector` 加法。

同时，我们依旧可以为 `Vector` 设置两套比较方式：

```aoi
struct Vector {
    x: float;
    y: float;
}
impl PartialOrdByX of PartialOrd[Vector] {
    op a < b {
        a.x < b.x
    }
}
impl PartialOrdByY of PartialOrd[Vector] {
    op a < b {
        a.y < b.y
    }
}
impl OrdByX of Ord[Vector: PartialOrdByX[Vector]] {}
impl OrdByY of Ord[Vector: PartialOrdByY[Vector]] {}
```

`OrdByX` 和 `OrdByY` 分别在 `PartialOrdByX` 和 `PartialOrdByY` 的基础上实现了 `Ord`。

---

如果一个特征有要求 `Foo[T: Bar[T]]`，那么要求 `T: Foo[T]` 本质上是要求 `Bar[T]` 和 `Foo[T]` 分别的实现。如果有另一个特征有相同的要求 `Baz[T: Bar[T]]`，同时要求 `T: Foo[T], Baz[T]` 时，也就是所谓的菱形继承，本质上是要求 `Foo` `Baz` `Bar` 三个实现。假如传入的 `Foo` 和 `Baz` 的实现中，其中的 `Bar` 的实现不是同一个，那么这是不被允许的。

描述很混乱，例子很清晰：

```
trait Ord[T] {
    op a < b: T <> T -> bool;
    op a <= b: T <> T -> bool {
        a < b || a == b
    }
    op a > b: T <> T -> bool {
        !(a <= b)
    }
    op a >= b: T <> T -> bool {
        !(a < b)
    }
}
trait Min[T: Ord[T]] {
    op min (a, b): (T, T) -> T {
        if a <= b then a else b;
    }
}
trait Max[T: Ord[T]] {
    op max (a, b): (T, T) -> T {
        if a >= b then a else b;
    }
}
op a clamp[T: Min[T], Max[T]] (minVal, maxVal): T <> (T, T) -> T {
    a = max(a, minVal);
    a = min(a, maxVal);
    a
}
struct Vector {
    x: float;
    y: float;
}
impl OrdByX of Ord[Vector] {
    op a < b {
        a.x < b.x
    }
}
impl OrdByY of Ord[Vector] {
    op a < b {
        a.y < b.y
    }
}
impl MinByX of Min[Vector: OrdByX[Vector]] {}
impl MinByY of Min[Vector: OrdByY[Vector]] {}
impl MaxByX of Max[Vector: OrdByX[Vector]] {}
impl MaxByY of Max[Vector: OrdByY[Vector]] {}
```

使用 `clamp` 时，`clamp[Vector: MaxByX, MinByX]` 是可行的，它分别传入了 `MaxByX` `MinByX` `OrdByX` 三个实现。但 `clamp[Vector: MaxByY, MinByX]` 是不可行的，因为 `MaxByY` 和 `MinByX` 拥有不同的 `Ord` 实现。可以看出，这种不可行的情况也没有实际意义。

## 泛型要求的简写

如果一个泛型类拥有太多的要求：

```aoi
struct Foo[T: Bar[T], Baz[T], Qux[T], ...]
```

那么，如果需要一个「可以当作 `Foo` 的泛型参数」的泛型参数，就需要再写一遍这一系列要求：

```aoi
op setFoo[T: Bar[T], Baz[T], Qux[T], ...] foo: Foo[T] -> ()
```

这样比较麻烦，因此可以用 `Foo[T]` 表示 `T` 满足 `Foo[T]` 中 `T` 需要的所有要求：

```aoi
op setFoo[T: Foo[T]] foo: Foo[T] -> ()
```

事实上，对于特征 `Foo[T: Bar[T]]`，要求 `T: Foo[T]` 实际上也是对要求 `T: Foo[T], Bar[T]` 的简写，实际上这个要求需要 `Foo` 和 `Bar` 分别的实现。
