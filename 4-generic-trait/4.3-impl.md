# 4.3 实现

定义特征后需要相应的实现，特征才有意义。

## 特征实现

定义一个特征实现的语法如下：

```aoi
impl ImplName of TraitName[Type0, Type1, ...] {
    ...
}
```

其中，`ImplName` 是实现的名称，它是可选的，若给出，则为具名实现，若不给出，则为默认实现。`TraitName` 是要实现的特征名，`Type` 是特征的类型实参。大括号中是特征中声明的运算符的实现。若可以，冒号及其之后的类型说明可以省略。

例如，以下代码定义了 `VectorSpace[float, Vector]` 的一个默认实现：

```aoi
struct Vector {
    x: float;
    y: float;
}
impl of VectorSpace[float, Vector] {
    op a * u {
        new Vector {
            x: a * u.x,
            y: a * u.y
        }
    }
}
```

令人震惊的是，Aoi 中，对同一个特征，相同的类型参数可以有多个不同的实现。具体地说，Aoi 只能有一个默认实现，但可以有多个名称不同的具名实现。

这样设定的意义在于，即使是相同的类型，对一个特征也可能有不同的实现方法。例如，为向量类实现排序特征，这时就可能需要按照 x 排序或按照 y 排序等多种实现：

```aoi
trait Ord[T] {
    op a < b: T <> T -> bool;
    op a <= b: T <> T -> bool {
        a < b || a == b
    }
    op a > b: T <> T -> bool {
        !(a <= b)
    }
    op a >= b: T <> T -> bool {
        !(a < b)
    }
}
struct Vector {
    x: float;
    y: float;
}
impl OrdByX of Ord[Vector] {
    op a < b {
        a.x < b.x
    }
}
impl OrdByY of Ord[Vector] {
    op a < b {
        a.y < b.y
    }
}
```

如果有一个函数接受一个 `Ord` 的实现对数组排序，那么通过给出两个不同的实现就可以按照不同的方式排序。至于如何接受一个特征的实现，将在后文展开。

---

可以使用 `=` 为一个实现使用另一个实现，例如，将 `OrdByX` 设为 `Ord[Vector]` 的默认实现：

```aoi
impl of Ord[Vector] = OrdByX;
```

这样后续如果想要修改默认实现，但是需要保留 `OrdByX` 的实现时更为方便。

## 非特征实现

如果实现中没有 `of Trait[...]`，那么这就是一个非特征实现：

```aoi
impl ImplName {
    ...
}
```

`ImplName` 为实现名，必须给出，`{ ... }` 中可以定义任意的若干表达式。实现名可以与现有的类型标识符重名。

除了语法形式一样，它和特征与特征实现没什么关系。它的作用主要为给运算符分类，使结构更清晰。同时，可以为非特征实现添加泛型，以简化相同的泛型在多个运算符中重复声明的情况，这将在后文介绍。

例如，为 `Vector` 添加同名的实现：

```aoi
struct Vector {
    x: float;
    y: float;
}
impl Vector {
    op a dot b: Vector <> Vector -> float {
        a.x * b.x + a.y * b.y
    }
}
```

事实上，这很像 Rust 中的 `impl Type`，但 Aoi 中更为自由，实现名称也不必须为类型。可以认为 Aoi 的实现不是「属于某个类型的」，而是「关于某个或某些类型的」。

## 显式或隐式地指定实现中的运算符

如果需要直接使用一个实现中的运算符，对于默认实现，在没有歧义的情况下可以直接用运算符名称隐式指定。若有歧义，需要显式指定默认实现中的方法。`TraitName[T0, T1, ...]::opName` 表示特征 `TraitName[T0, T1, ...]` 的默认实现中的 `opName` 方法。

对于具名实现，需要用 `ImplName::opName` 显式指定，否则显然会出现多个实现打架的情况。

例如，对上述 `VectorSpace[float, Vector]` 的默认实现，可以用 `a * u` 直接使用实现中的乘法运算符，也可以显式地用 `a VectorSpace[float, Vector]::* u` 使用其中的乘法运算符。对上述 `Ord[Vector]` 的两个具名实现，可以用 `u OrdByX::< v` 和 `u OrdByY::< v` 分别使用其中的小于运算符。

---

对于一些情况：

```aoi
trait Default[T] {
    op getDefault (): () -> T;
}
```

可以预见，如果这个特征有多个默认实现，那么这些实现的 `getDefault` 都被暴露出来，根本无法判断一个 `getDefault` 究竟是哪个实现中的。对于这些情况，可以在运算符前加 `TraitName::` 要求它必须被显式地指定。对于上述例子，可以改为：

```aoi
trait Default[T] {
    op Default::getDefault (): () -> T;
}
```

这时，想要使用某个特定实现，例如 `Default[int]` 的 `getDefualt`，就必须用 `Default[int]::getDefault`。

在实现时，对应运算符的声明无需加前缀。例如：

```aoi
impl of Default[int] {
    op getDefault () { 0 }
}
```

对于一些情况：

```aoi
trait Foo {
    op baz (): () -> ();
}
trait Bar {
    op baz (): () -> ();
}
```

可以看出，`Foo` 和 `Bar` 中有一个重名的运算符 `baz`，若同时实现两个特征，则会出现运算符重名。这时，可以在实现里用 `TraitName::` 要求运算符必须被显式地指定：

```
impl of Foo {
    op Foo::baz () { ... }
}
impl of Bar {
    op Bar::baz () { ... }
}
```

这样，两个运算符就只能分别用 `Foo::baz` 和 `Bar::baz` 指定。

这类似于其它语言中的显式实现接口，它们解决的是相同的问题。

---

非特征实现中的运算符可以隐式指定，也可以用 `ImplName::opName` 显式指定。

对于一些情况：

```aoi
struct Vector {
    x: float;
    y: float;
}
impl Vector {
    op create (x, y): (float, float) -> Vector {
        new Vector {
            x: x,
            y: y
        }
    }
}
```

显然，`Vector::create` 语义更清晰且能避免重名。在实现中用 `ImplName::` 以要求运算符必须被显式地指定：

```aoi
impl Vector {
    op Vector::create (x, y): (float, float) -> Vector {
        new Vector {
            x: x,
            y: y
        }
    }
}
```

这类似于其它语言的静态方法的调用方式。
