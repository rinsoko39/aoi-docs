# 4.1 泛型

运算符和类型可以接受若干类型作为泛型参数。

## 泛型运算符

一般运算符、类型转换运算符、getter 和 setter 都可以接受泛型参数。它们的语法分别如下：

```aoi
op lhs opName[T0, T1, ...] rhs: LhsType RhsType -> ResultType {
    ...
}
```

```aoi
convert xxplicit[T1, T2, ...] value: FromType -> ToType {
    ...
}
```

```aoi
get[T1, T2, ...] self.proertyName: SelfType -> PropertyType {
    ...
}
```

```aoi
set[T1, T2, ...] self.propertyName = value: SelfType <- PropertyType {
    ...
}
```

```aoi
get[T1, T2, ...] self.[index]: SelfType IndexType -> PropertyType {
    ...
}
```

```aoi
set[T1, T2, ...] self.[index] = value: SelfType IndexType <- PropertyType {
    ...
}
```

其中，`T` 为泛型参数，可以在 `LhsType` `RhsType` `ResultType` 中使用。

用 `lhs opName[Type1, Type2, ...] rhs` 显式指定一般运算符的泛型参数。其中每个 `Type` 都为可选，若为空，则将自动推导。若未显式指定泛型参数，则所有参数均将自动推导。

类型转换运算符、getter 和 setter 不能显式指定泛型参数。一般来说，它们都能自动推导出泛型类型。

## 泛型类型

可以定义带泛型的结构体、类和联合体。它们的语法分别如下：

```aoi
struct StructName[T0, T1, ...] {
    ...
}
```

```aoi
class ClassName[T0, T1, ...] {
    ...
}
```

```aoi
union UnionName[T0, T1, ...] {
    ...
}
```

其中，`T` 为泛型参数，可以在类型的定义中使用。

例如，以下升级了 3.3 中的简单字典，定义了一个键值可以为任意类型的字典：

```aoi
class Dictionary[TKey, TValue] {
    keyValuePairs: arr[(Tkey, TValue)];
}
get[TKey, TValue] self.length: Dictionary[TKey, TValue] -> int {
    self.keyValuePairs.length
}
get[TKey, TValue] self.[key]: Dictionary[TKey, TValue] <> TKey -> TValue {
    for (k, v) in self.keyValuePairs do {
        if k == key then {
            return v;
        }
    }
    throw new KeyNotFoundException {}
}
set[TKey, TValue] self.[key] = value: Dictionary[TKey, TValue] <> TKey <- TValue {
    for i in 0..self.length do {
        if self.keyValuePairs.[i].0 == key then {
            self.keyValuePairs.[i].1 = value;
            return;
        }
    }
}
```

目前，由于泛型参数未知且可以为任意类型，对泛型对象无法使用任何运算符，除了 `==` `!=` 等所有类型都实现的运算符。后文中，将介绍特征，以此明确可以作用于泛型类型的运算符。
