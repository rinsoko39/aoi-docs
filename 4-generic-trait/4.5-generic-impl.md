# 4.5 带泛型的实现

## 带泛型的特征实现

可以为所有满足一些特征的类型都实现某个特征：

```aoi
impl[T0, T1, ...: Trait0[...], Trait1[...], ...] of Trait[...] {
    ...
}
```

```aoi
impl ImplName[T0, T1, ...: Trait0[...], Trait1[...], ...] of Trait[...] {
    ...
}
```

例如：

```aoi
struct Vector[T: Add[T], Sub[T]] {
    x: T;
    y: T;
}
impl[T: Vector[T]] of Add[Vector[T]] {
    op a + b {
        new Vector {
            x: a.x + b.x,
            y: a.y + b.y
        }
    }
}
```

以上代码为所有 `Vector[T]` 实现了加法。

默认实现的泛型参数不能显式指定，只能隐式地推导。Aoi 中存在一个规律，定义中只有标识符后的泛型能显式指定，且形式与定义一致。关键字后的泛型均无法显式指定，例如 `impl[...]` `get[...]` 等。

类型相同时一个特征只能有一个默认实现。不能出现默认实现重复的情况，这和 Rust 中是一样的。例如，以下是不被允许的：

```aoi
trait Foo[T] {
    ...
}
struct Vector[T] {
    ...
}
impl[T] of Foo[Vector[T]] {
    ...
}
impl of Foo[Vector[bool]] {
    ...
}
```

此时，对于 `Foo[Vector[bool]]`，将不知道究竟该采用哪个实现。禁止这么做可以避免类似 C++ 中 `vector<bool>` 的逆天情况。
