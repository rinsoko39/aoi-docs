# 1.4 结构体与类

结构体与类存储若干字段。

结构体与类的区别在于前者是值类型，后者是引用类型。其余在语法上相同。

定义一个结构体的语法如下：

```aoi
struct StructName {
    fieldName0: Type0;
    fieldName1: Type1;
    ...
}
```

定义一个类的语法如下：

```aoi
class ClassName {
    fieldName0: Type0;
    fieldName1: Type1;
    ...
}
```

其中，`StructName` 或 `ClassName` 是结构体或类的类型名，`fieldName` 是字段名，`Type` 是字段类型。

在结构体或类的定义块中只有结构体的字段，而没有方法等（因为 Aoi 根本没有这些东西）。

---

用 `new` 表达式创建一个实例：

```aoi
new Type {
    field0: value0,
    field1: value1,
    ...
}
```

其中，`Type` 是结构体或类的类型名，`field` 是字段名，`value` 是要赋给字段的值。

Aoi 中没有默认值，因此所有字段的值都必须在 `new` 表达式中给出，或使用 `unset` 标明未初始化，详见下文。

Aoi 中不能自定义构造函数。可以自定义运算符用于创建实例。

Aoi 中创建实例需要 `new` 关键字，而不像 Rust 中的 `Type { ... }`，这是因为后者在 Aoi 中会被识别为一个表达式块转换为 `Type` 类型。

---

通过 `instance.fieldName` 访问实例 `instance` 中的字段 `fieldName`。

---

用 `set` 表达式批量修改一个实例，语法如下：

```
instance set {
    field0: value0,
    field1: value1,
    ...
}
```

其中，`instance` 是数组实例，`field` 是字段名，`value` 是要赋给字段的值。

`set` 表达式返回实例本身。

## `unset`

虽然 Aoi 中没有默认值，但是像是循环引用等地方还是不得不暂时不为字段提供值。这时，使用 `unset` 来显式标明。这么做是不安全的，Aoi 不会检查后续该值是否被赋值，访问未赋值的字段是未定义行为。如非必要，请勿使用。想要做到检查后续字段是否被赋值是很难的，因为一个有字段未被赋值的实例可能会跨运算符传递。比起语法检查，更好的做法是通过文档标明，当然，不使用是最好的。

例如，创建一个自引用的类实例：

```aoi
struct SelfReferentiality {
    self: SelfReferentiality;
}
let instance = new SelfReferentiality {
    self: unset
}
instance.self = instance;
```
